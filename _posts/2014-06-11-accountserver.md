---

layout: post
title: "账号服务器"
description: "AccountServer"
category: Development
tags: [AccountServer]
---
{% include JB/setup %}

### 需求分析

------------------------------------------------------------------------

#### 基本需求

1.  服务器列表的下发
2.  账号数据的查询与验证
3.  第三方账号验证

#### 扩展需求

1.  激活码
2.  ~~登录排队~~
3.  VIP（充值？）
4.  账户防沉迷

### 框架设计

------------------------------------------------------------------------

**架构选择**

账服-AS 游服-GS 数据库-DB

1.  GS:AS:DB =

**网络IO**

1.  ~~异步SELECT~~
    ## ~~公司现有ServerSocket~~
2.  IOCP
    ## ~~libevent~~
    ## ~~acelite~~
    ## **libuv**

**线程划分**

1.  连接线程
2.  逻辑线程

**日志工具**

1.  log4cpp

**内存数据库**

1.  [SQLite](http://www.it168.com/redian/imdb2012/)
2.  redis
3.  memcached
4.  mysql

开发日志
--------

------------------------------------------------------------------------

### 2014-6-18

-   定基本架构：
    **** 最初的设想是Socket使用libuv的IOCP提高并发率
    **** 使用BufferPool预分配缓冲，以实现收发消息的零拷贝
    **** 进程间通信使用lock-free的消息队列
-   一切看起来都很美好，但是真正开始考虑实现的时候，发现大量的问题接踵而至:
    **** libuv确实是个简单易用的库，不过它的回调机制和C++面向对象机制格格不入，因为类成员函数无法作为回调函数，因此想要做优雅的对象封装实在难以实现
    **** 预分配缓冲池是个不错的想法，但是同样碰到了锁的问题，如果缓冲池无法做到lock-free，那么多个线程很可能对缓冲池操作发起竞争，这样的代价可能比直接用new申请更糟糕。于是我不得不重新考虑使用缓冲池的方案了。
    **** 大部分的lock-free队列实现都使用了C** 11的原子操作，但是VS2008是无法支持的，因此不得不放弃这个想法
-   所以现在的计划就是先用简单的new/delete方式来分配缓冲，搭配IOCP,看看能做到什么程度
-   目前已经能做到和客户端通信了，简单的使用回显已经OK

### 2014-6-19

-   找到一个折中的方案，单线程内使用环形缓冲，这样不用频繁的为消息申请内存，跨线程通信memcpy一次，这样就无需考虑lock-free的问题。
-   从网上找到一个环形缓冲的实现，是一个貌似挺有名还出过书的老外写的，稍微瞄了几眼代码，跑了一次他的测试用例，觉得没啥问题就拿来用了，结果就悲剧了。at()里面出现一处低级错误(size-&gt;index)。看来即使老外的LIB也不能全信啊。让我想起了HeartBleed。
-   测试过程中发现一个内存泄露，uv_listen的时候，libuv内部会申请一块内存。但是uv_close的时候，这块内存空间并不会立即被释放，libuv会事件循环发送一个endgame,要等到下个循环处理endgame时，才会被释放掉。但是我用的是公司的线程实现，一旦closeThread线程就被终止了，根本没有机会做清理。因此我不得不对线程循环做了一些改造。
-   改造完成后又发现如果还有客户端连接在服务器上，服务器不会关闭，即使已经将服务端的SOCKET用uv_close关闭了，原因服务器上的对端SOCKET没有关闭，uv_run认为还有事件等待处理，因此不会返回0。
